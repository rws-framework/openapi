import { Injectable } from '@rws-framework/server/nest';  
import { RWSConfigService } from '@rws-framework/server';  
import {  IHTTProute, IPrefixedHTTProutes } from '@rws-framework/server/src/routing/routes';  
import { 
  OpenAPISpec, 
  OpenAPIPath, 
  OpenApiParameter, 
  OpenApiRouteParamTypes,
  OpenApiSpecRequest,
  OpenApiSpecResponse,
  OpenApiRouteParamResponseType,
  IOpenApiGenerateParams,
  IOpenApiRouteParams,
  OpenAPIMethodSpec
} from '../types/openapi';

const DEFAULT_PARAMS = {
  version: '1.0.0',
  title: 'OpenAPI documentation generated by RWS',
  description: 'API documentation generated from RWS routes',
};

@Injectable()
export class RWSOpenApiService
{
  private defaultServer: string;

    constructor(private configService: RWSConfigService){
      this.defaultServer = `${this.configService.get('domain')}${this.configService.get('port') && this.configService.get('port') !== 80 ? (':' + this.configService.get('port')) : ''}`;
    }

    private getRWSRoutes(): IPrefixedHTTProutes<IOpenApiRouteParams>[]
    {
        return this.configService.get('http_routes') as IPrefixedHTTProutes<IOpenApiRouteParams>[];
    }

    private convertParamTypesToSchema(params: OpenApiRouteParamTypes): OpenApiSpecRequest['schema'] {
      const properties: { [key: string]: any } = {};
      
      for (const [key, value] of Object.entries(params)) {
        properties[key] = {
          type: value.type,
          description: value.description
        };
      }

      return {
        type: 'object',
        properties
      };
    }
 
    generateOpenAPI(passedParams: Partial<IOpenApiGenerateParams> = {
      version: DEFAULT_PARAMS.version,
      title: DEFAULT_PARAMS.title,
      description: DEFAULT_PARAMS.description,
      server: this.defaultServer
    }): OpenAPISpec {
      const routes: IPrefixedHTTProutes<IOpenApiRouteParams>[] = this.getRWSRoutes();
      const params: IOpenApiGenerateParams  = {...DEFAULT_PARAMS, ...passedParams};

      if(!params.server){
        params.server = this.defaultServer;
      }
      
      const openApiSpec: OpenAPISpec = {
        openapi: "3.0.0",
        info: {
          title: params.title,
          description: params.description,
          version: params.version
        },
        paths: {},
        servers: [{
          url: params.server
        }]
      };
  
      if (Array.isArray(routes)) {
        for (const prefixedRoute of routes) {
          const { prefix, controllerName, routes: subRoutes } = prefixedRoute;
          
          for (const route of subRoutes) {
            const fullPath = `${prefix}${route.path}`;
            const method = route.method.toLowerCase();
  
            if (!openApiSpec.paths[fullPath]) {
              openApiSpec.paths[fullPath] = {};
            }
  
            const methodSpec: OpenAPIMethodSpec = this.initSpec(controllerName, route);

            if (route.plugins?.openapi?.payload) {
              this.populateRequest(route, methodSpec)
            }

            if (route.plugins?.openapi?.responses) {
              this.populateResponse(route, methodSpec);
            }
  
            // Add parameters if route has them and they're not explicitly disabled
            if (!route.noParams) {
              const parameters: OpenApiParameter[] = this.getParameters(route);
                          
              if (parameters.length > 0) {
                methodSpec.parameters = parameters;
              }
            }

            openApiSpec.paths[fullPath][method] = methodSpec;
          }
        }
      }
  
      return openApiSpec;
    }

    private initSpec(controllerName: string, route: IHTTProute<IOpenApiRouteParams>): OpenAPIMethodSpec
    {
      return {
        tags: [controllerName],
        summary: route.name,
        responses: {
          '200': {
            description: 'Successful operation',
            content: {
              'application/json': {
                schema: {
                  type: 'object'
                }
              }
            }
          }
        },
        requestBody: {
          required: true,
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {}
              }
            }
          }
        }
      }
    }

    private getParameters(route: IHTTProute<IOpenApiRouteParams>): OpenApiParameter[]
    {
      const parameters: OpenApiParameter[] = [];
              
      const pathParams = route.path.match(/\{(\w+)\}/g);
      if (pathParams) {
        for (const param of pathParams) {
          const paramName = param.replace(/[{}]/g, '');
          parameters.push({
            name: paramName,
            in: 'path',
            required: true,
            schema: {
              type: 'string'
            }
          });
        }
      }

      return parameters;
  
    }

    private populateRequest(route: IHTTProute<IOpenApiRouteParams>, methodSpec: OpenAPIPath[string][string]): void
    {
      methodSpec.requestBody = {
        required: true,
        content: {
          'application/json': {
            schema: this.convertParamTypesToSchema(route.plugins.openapi.payload)
          }
        }
      };
    }

    private populateResponse(route: IHTTProute<IOpenApiRouteParams>, methodSpec: OpenAPIPath[string][string]): void
    {
      for (const responseCode in route.plugins.openapi.responses) {
        const routeResponse: OpenApiRouteParamResponseType = route.plugins.openapi.responses[responseCode];

        const specsResponse: OpenApiSpecResponse = {
          description: routeResponse.description || 'Operation response',
          content: {
            'application/json': {
              schema: this.convertParamTypesToSchema(routeResponse.returnParams)
            }
          }
        };

        methodSpec.responses[responseCode] = specsResponse;
      }    
    }
}