import { Injectable } from '@rws-framework/server/nest';  
import { RWSConfigService } from '@rws-framework/server';  
import {  IHTTProute, IPrefixedHTTProutes } from '@rws-framework/server/src/routing/routes';  
import { 
  OpenAPISpec, 
  OpenAPIPath, 
  OpenApiParameter, 
  OpenApiRouteParamTypes,
  OpenApiSpecRequest,
  OpenApiSpecResponse,
  OpenApiRouteParamResponseType,
  IOpenApiGenerateParams,
  IOpenApiRouteParams,
  OpenAPIMethodSpec
} from '../types/openapi';

const DEFAULT_PARAMS = {
  version: '1.0.0',
  title: 'OpenAPI documentation generated by RWS',
  description: 'API documentation generated from RWS routes',
};

@Injectable()
export class RWSOpenApiService
{
  private defaultServer: string;

    constructor(private configService: RWSConfigService){
      this.defaultServer = `${this.configService.get('domain')}${this.configService.get('port') && this.configService.get('port') !== 80 ? (':' + this.configService.get('port')) : ''}`;
    }

    private getRWSRoutes(): IPrefixedHTTProutes<IOpenApiRouteParams>[]
    {
        return this.configService.get('http_routes') as IPrefixedHTTProutes<IOpenApiRouteParams>[];
    }

    private convertParamTypesToSchema(params: OpenApiRouteParamTypes): OpenApiSpecRequest['schema'] {
      const properties: { [key: string]: any } = {};
      const required: string[] = [];

      for (const [key, value] of Object.entries(params)) {
        if (typeof value === 'object' && value !== null) {
          // Handle direct schema definitions (objects with type, oneOf, etc.)
          if ('type' in value || 'oneOf' in value || 'enum' in value) {
            const propertySchema: any = {
              ...(value.type && { type: value.type }),
              ...(value.description && { description: value.description })
            };

            // Handle nested objects
            if (value.type === 'object' && value.properties) {
              const nestedSchema = this.convertParamTypesToSchema(value.properties);
              propertySchema.properties = nestedSchema.properties;
              if (nestedSchema.required) {
                propertySchema.required = nestedSchema.required;
              }
            }

            // Handle arrays
            if (value.type === 'array' && value.items) {
              propertySchema.items = value.items;
            }

            // Handle oneOf structures
            if (value.oneOf) {
              propertySchema.oneOf = value.oneOf;
              if (propertySchema.type) {
                delete propertySchema.type; // Remove type when using oneOf
              }
            }

            // Handle enum values
            if (value.enum) {
              propertySchema.enum = value.enum;
            }

            // Handle format
            if (value.format) {
              propertySchema.format = value.format;
            }

            properties[key] = propertySchema;

            if (value.required) {
              required.push(key);
            }
          } else {
            // Handle direct property definitions (any other object structure)
            properties[key] = value;
          }
        } else {
          // Handle primitive values
          properties[key] = value;
        }
      }

      const schemaObject: any = {
        type: 'object',
        properties        
      };

      if (required.length > 0) {
        schemaObject.required = required;
      }

      return schemaObject;
    }
 
    generateOpenAPI(passedParams: Partial<IOpenApiGenerateParams> = {
      version: DEFAULT_PARAMS.version,
      title: DEFAULT_PARAMS.title,
      description: DEFAULT_PARAMS.description,
      server: this.defaultServer
    }): OpenAPISpec {
      const routes: IPrefixedHTTProutes<IOpenApiRouteParams>[] = this.getRWSRoutes();
      const params: IOpenApiGenerateParams  = {...DEFAULT_PARAMS, ...passedParams};

      if(!params.server){
        params.server = this.defaultServer;
      }
      
      const openApiSpec: OpenAPISpec = {
        openapi: "3.0.0",
        info: {
          title: params.title,
          description: params.description,
          version: params.version
        },
        paths: {},
        servers: [{
          url: params.server
        }]
      };
  
      if (Array.isArray(routes)) {
        for (const prefixedRoute of routes) {
          const { prefix, controllerName, routes: subRoutes } = prefixedRoute;
          
          for (const route of subRoutes) {
            // Handle route.path as array
            const paths = Array.isArray(route.path) ? route.path : [route.path];
            
            for (const path of paths) {
              const fullPath = `${prefix}${path}`;
              const method = route.method.toLowerCase();

              if (!route.plugins?.openapi) {
                continue;
              }        
    
              if (!openApiSpec.paths[fullPath]) {
                openApiSpec.paths[fullPath] = {};
              }
    
              const methodSpec: OpenAPIMethodSpec = this.initSpec(controllerName, route);

              if (route.plugins?.openapi?.payload) {
                this.populateRequest(route, methodSpec)
              }

              if (route.plugins?.openapi?.responses) {
                this.populateResponse(route, methodSpec);
              }
    
              // Add parameters if route has them and they're not explicitly disabled
              if (!route.noParams) {
                const parameters: OpenApiParameter[] = this.getParameters(route, path);
                            
                if (parameters.length > 0) {
                  methodSpec.parameters = parameters;
                }
              }

              openApiSpec.paths[fullPath][method] = methodSpec;
            }
          }
        }
      }
  
      return openApiSpec;
    }

    private initSpec(controllerName: string, route: IHTTProute<IOpenApiRouteParams>): OpenAPIMethodSpec
    {
      const spec: OpenAPIMethodSpec = {
        tags: [controllerName],
        summary: route.name,
        description: route.plugins?.openapi?.description || `${route.method} ${route.name}`,
        responses: {
          '200': {
            description: 'Successful operation',
            content: {
              'application/json': {
                schema: {
                  type: 'object'
                }
              }
            }
          }
        }
      };

      // Only add requestBody for methods that typically have one
      const methodsWithBody = ['post', 'put', 'patch'];
      if (methodsWithBody.includes(route.method.toLowerCase())) {
        spec.requestBody = {
          required: true,
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {}
              }
            }
          }
        };
      }

      return spec;
    }

    private getParameters(route: IHTTProute<IOpenApiRouteParams>, specificPath?: string): OpenApiParameter[]
    {
      const parameters: OpenApiParameter[] = [];
      
      // Use the specific path if provided, otherwise use the first path from route.path
      const pathToCheck = specificPath || (Array.isArray(route.path) ? route.path[0] : route.path);
              
      // Check for both {param} and :param syntax
      const pathParams = pathToCheck.match(/[:{](\w+)[}]?/g);
      if (pathParams) {
        for (const param of pathParams) {
          const paramName = param.replace(/[:{}]/g, '');
          parameters.push({
            name: paramName,
            in: 'path',
            required: true,
            schema: {
              type: 'string'
            }
          });
        }
      }

      return parameters;
  
    }

    private populateRequest(route: IHTTProute<IOpenApiRouteParams>, methodSpec: OpenAPIMethodSpec): void
    {
      if (route.plugins?.openapi?.payload) {
        // Ensure methodSpec has requestBody
        if (!methodSpec.requestBody) {
          methodSpec.requestBody = {
            required: true,
            content: {
              'application/json': {
                schema: {
                  type: 'object',
                  properties: {}
                }
              }
            }
          };
        }
        
        // If the payload has a "body" property, use that directly as the schema
        if (typeof route.plugins.openapi.payload === 'object' && 'body' in route.plugins.openapi.payload && route.plugins.openapi.payload.body) {
          methodSpec.requestBody.content['application/json'].schema = route.plugins.openapi.payload.body;
        } else {
          methodSpec.requestBody.content['application/json'].schema = this.convertParamTypesToSchema(route.plugins.openapi.payload as OpenApiRouteParamTypes);
        }
      }
    }

    private populateResponse(route: IHTTProute<IOpenApiRouteParams>, methodSpec: OpenAPIMethodSpec): void
    {
      if (!route.plugins?.openapi?.responses) {
        return;
      }
      
      for (const responseCode in route.plugins.openapi.responses) {
        const routeResponse: any = route.plugins.openapi.responses[responseCode];

        const specsResponse: OpenApiSpecResponse = {
          description: routeResponse.description || 'Response ' + responseCode
        };

        // Check if response already has content defined (custom content types, schemas, examples)
        if (routeResponse.content) {
          specsResponse.content = routeResponse.content;
        }
        // Otherwise, generate content from returnParams if they exist
        else if (routeResponse.returnParams && Object.keys(routeResponse.returnParams).length > 0) {
          specsResponse.content = {
            'application/json': {
              schema: routeResponse.returnParams
            }
          };
        }

        methodSpec.responses[responseCode] = specsResponse;
      }
    }
}